#include "Rinternals.h"
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define n_pass_rank 2
#define n_pass_value 4
#define shift 16
#define n_bucket 65536
#define mask 0xFFFF

struct uniqueN_data {
  uint32_t rank;
  uint64_t value;
};

void rsort(struct uniqueN_data *x, int n, int hist_rank[][n_bucket],
           int hist_value[][n_bucket]) {

  struct uniqueN_data *s = (struct uniqueN_data *) malloc(n * sizeof(struct uniqueN_data));

  int not_skip_rank[n_pass_rank];
  for (int j = 0; j < n_pass_rank; j++) {
    not_skip_rank[j] = -1;
    int cumsum = 0;
    for (int i = 0; i < n_bucket; i++) {
      if (hist_rank[j][i] != 0) not_skip_rank[j]++;
      cumsum += hist_rank[j][i];
      hist_rank[j][i] = cumsum - hist_rank[j][i];
    }
  }

  int not_skip_value[n_pass_value];
  for (int j = 0; j < n_pass_value; j++) {
    not_skip_value[j] = -1;
    int cumsum = 0;
    for (int i = 0; i < n_bucket; i++) {
      if (hist_value[j][i] != 0) not_skip_value[j]++;
      cumsum += hist_value[j][i];
      hist_value[j][i] = cumsum - hist_value[j][i];
    }
  }

  int pass = 0;
  for (int j = 0; j < n_pass_rank; j++) {
    if (!not_skip_rank[j]) continue;

    for (int i = 0; i < n; i++) {
      unsigned int pos = (x + i)->rank >> j * shift & mask;
      s[hist_rank[j][pos]++] = x[i];
    }

    struct uniqueN_data *tmp = s;
    s = x;
    x = tmp;

    pass++;
  }

  for (int j = 0; j < n_pass_value; j++) {
    if (!not_skip_value[j]) continue;

    for (int i = 0; i < n; i++) {
      unsigned int pos = (x + i)->value >> j * shift & mask;
      s[hist_value[j][pos]++] = x[i];
    }

    struct uniqueN_data *tmp = s;
    s = x;
    x = tmp;

    pass++;
  }

  if (pass % 2 != 0) memcpy(s, x, n * sizeof(struct uniqueN_data));
}

SEXP rsort(SEXP xx) {
  int n = LENGTH(xx);
  unsigned int *x = (unsigned int *) INTEGER(xx);

  SEXP sort1 = PROTECT(allocVector(INTSXP, n));
  unsigned int *s1 = (unsigned int *) INTEGER(sort1);

  SEXP sort2 = PROTECT(allocVector(INTSXP, n));
  unsigned int *s2 = (unsigned int *) INTEGER(sort2);

  memcpy(s1, x, n * 4);



  int hist[n_pass][n_bucket];
  memset(hist, 0, n_pass * n_bucket * 4);


  for (int j = 0; j < n_pass; j++) {
    for (int i = 0; i < n; i++) {
      hist[j][x[i] >> j * shift & mask]++;
    }
  }

  int not_skip[n_pass];
  for (int j = 0; j < n_pass; j++) {
    not_skip[j] = -1;
    int cumsum = 0;
    for (int i = 0; i < n_bucket; i++) {
      if (hist[j][i] != 0) not_skip[j]++;
      cumsum += hist[j][i];
      hist[j][i] = cumsum - hist[j][i];
    }
  }

  int pass = 0;
  for (int j = 0; j < n_pass; j++) {
    if (!not_skip[j]) continue;

    for (int i = 0; i < n; i++) {
      unsigned int pos = s1[i] >> j * shift & mask;
      s2[hist[j][pos]++] = s1[i];
    }

    unsigned int *tmp = s2;
    s2 = s1;
    s1 = tmp;

    pass++;
  }

  UNPROTECT(2);
  if (pass % 2 == 0) {
    return sort1;
  } else {
    return sort2;
  }

}

int cmp(const void *xx, const void *yy) {
  int x = *((int *) xx);
  int y = *((int *) yy);

  return (x > y) - (y > x);
}

SEXP qsort_SEXP(SEXP xx) {
  int n = LENGTH(xx);
  unsigned int *x = (unsigned int *) INTEGER(xx);

  SEXP sort1 = PROTECT(allocVector(INTSXP, n));
  unsigned int *s1 = (unsigned int *) INTEGER(sort1);

  memcpy(s1, x, n * 4);

  qsort(s1, n, 4, cmp);

  UNPROTECT(1);
  return sort1;
}
